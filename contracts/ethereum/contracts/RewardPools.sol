// SPDX-License-Identifier: GPL

// Copyright 2022 Fluidity Money. All rights reserved. Use of this
// source code is governed by a GPL-style license that can be found in the
// LICENSE.md file.

pragma solidity 0.8.11;
pragma abicoder v2;

import "./Token.sol";

/// @notice quick reward pool structure that getPools returns
struct RewardPool {
  uint256 amount;
  uint8 decimals;
}

/// @title Contract for getting information on the amounts contained
/// @title within each Token
contract RewardPools {
  uint private version_;

  /// @dev operator that's responsible for configuring these reward pools
  address operator_;

  /// @dev tokens that're tracked by this contract
  Token[] tokens_;

  /**
   * @notice initialiser function
   * @param _operator the address able to call functions including "addToken"
   * @param _tokens to track initially using the init function
   */
  function init(address _operator, Token[] memory _tokens) public {
    require(version_ == 0, "contract is already initialised");
    version_ = 1;
    operator_ = _operator;

    for (uint i = 0; i < _tokens.length; i++) {
      tokens_.push(_tokens[i]);
    }
  }

  /**
   * @notice `addToken` to the list of tokens that we support
   * @param t `Token` to add to the list of tracked tokens
   */
  function addToken(Token t) public {
    require(msg.sender == operator_, "only operator can use this function!");
    tokens_.push(t);
  }

  /**
   * @notice getPools supported by the token in the form of a list of the structs
   * @return rewardPool `RewardPool[]` generated by asking the `balanceOfUnderlying` on each `Token`
   */
  function getPools() public returns (RewardPool[] memory rewardPool) {
    rewardPool = new RewardPool[](tokens_.length);

    for (uint i = 0; i < tokens_.length; i++) {
      Token token = tokens_[i];
      RewardPool memory pool;

      pool.amount = token.rewardPoolAmount();
      pool.decimals = token.decimals();

      rewardPool[i] = pool;
    }
  }
}
