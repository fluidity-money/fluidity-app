// Copyright 2022 Fluidity Money. All rights reserved. Use of this
// source code is governed by a GPL-style license that can be found in the
// LICENSE.md file.

package util

// random implements cryptographically secure randomness

import (
	"crypto/rand"
	"fmt"
	"math/big"

	"github.com/fluidity-money/fluidity-app/lib/log"
)

// RandomString generated by creating a buffer of length / 2, filling it
// up with randomness then returning the base16 encoded form of it.
func RandomString(length int) string {
	buf := make([]byte, length/2)

	if _, err := rand.Read(buf); err != nil {
		log.Fatal(func(k *log.Log) {
			k.Context = Context
			k.Message = "Failed to get a securely random string!"
			k.Payload = err
		})
	}

	return fmt.Sprintf("%x", buf)
}

// generateRandomIntegers gated between min and max, inclusive on both ends,
// doing some coercion internally to use crypto/rand and assuming that the
// uint32 requirement in the arguments prevent any size-of-int issues
func RandomIntegers(amount int, min, max uint32) (numbers []uint32) {
	var (
		maxBig = new(big.Int).SetInt64(int64(max))
		minBig = new(big.Int).SetInt64(int64(min))
	)

	if int64(amount) > int64(max-min+1) {
		log.Fatal(func(k *log.Log) {
			k.Format(
				"Can't generate %d non-repeating integers between %d and %d!",
				amount,
				min,
				max,
			)
		})
	}

	numbers = make([]uint32, amount)

	scaledMax := new(big.Int).Sub(maxBig, minBig)

	// crypto/rand#Int generates from 0 (inclusive) to max (exclusive)
	scaledMax.Add(scaledMax, big.NewInt(1))

	for i := 0; i < amount; i++ {
		for {
			no, err := rand.Int(rand.Reader, scaledMax)

			if err != nil {
				log.Fatal(func(k *log.Log) {
					k.Message = "Failed to source system randomness!"
					k.Payload = err
				})
			}

			no.Add(no, minBig)

			// we can assume that with the arguments this is okay

			numbers[i] = uint32(no.Int64())

			dup := false

			for j := 0; j < i; j++ {
				if numbers[i] == numbers[j] {
					dup = true
					break
				}
			}

			if !dup {
				break
			}
		}
	}

	return numbers
}
